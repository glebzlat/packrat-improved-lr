# The algorithm is taken from "Improved Packrat Parser Left Recursion Support"
# by James R. Douglass

# This algorithm implements a "grow LR" operator '*>':
#
#   x <- S *> x R1 / x R2 / ... / x R
#
# The binary operator `*>` determines a seed from the left side expression `S`,
# then repeatedly evaluates the right hand expression with the ordered choices
# of items `x R`.

struct LRFail(heads: Set[Head], frame: Context)
struct MemoEntry(ans: Ast, pos: Position)
struct Head subclasses MemoEntry(chains: Array[Chain])

Memo(Rule, Pos) -> MemoEntry
Pos: int

ApplyRule(R, P)
    let m = Memo(R, P)
    if m = NIL then
        let e = new MemoEntry(new LRFail(NIL, thisContext), P)
        Memo(R, P) <- e
        e.ans <- Eval(R.body)
        e.pos <- Pos
        if e is Head then
            if e.ans is LRFail then
                # Grow LR
                e.ans <- Fail
            return ApplyGrowRule(e, P)
        return e.ans

    Pos <- m.pos
    if m.ans is LRFail then
        # LR detected
        if m.ans.heads = NIL then
            # New head
            m becomes Head(m.ans, m.pos, {})
            m.ans.heads <- {m}
        AddChain(thisContext, m.ans, heads)
    return m.ans

ApplyGrowRule(M, P)
    while True do
        # Left repetition while improvement
        Pos <- P
        for each c in M.chains do
            # Ordered choice
            let ans = Resume(c)  # On chain
            if ans != Fail then
                break
            Pos <- P
        if Pos <= M.pos then
            # No improvement
            Pos <- M.pos
            return M.ans
        M.ans <- ans
        M.pos <- Pos
